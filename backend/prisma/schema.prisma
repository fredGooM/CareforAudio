generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  USER
}

model User {
  id                 String          @id @default(uuid())
  email              String          @unique
  passwordHash       String
  firstName          String
  lastName           String
  role               Role            @default(USER)
  isActive           Boolean         @default(true)
  mustChangePassword Boolean         @default(true)
  avatar             String?
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  groups             UserGroup[]
  audioAccesses      AudioAccess[]
  progressRecords    UserProgress[]
  audioLogs          AudioLog[]
  refreshTokens      RefreshToken[]
}

model Group {
  id        String      @id
  name      String
  users     UserGroup[]
  audios    GroupAccess[]
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
}

model UserGroup {
  userId String
  groupId String

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@id([userId, groupId])
}

model AudioTrack {
  id           String        @id @default(uuid())
  title        String
  description  String?
  duration     Int           @default(0)
  storageKey   String        @unique
  mimeType     String?
  size         Int?
  categoryId   String?
  category     Category?     @relation(fields: [categoryId], references: [id])
  type         String   @default("Training")
  orderToListen Int     @default(1)
  published    Boolean       @default(false)
  coverUrl     String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  allowedUsers AudioAccess[]
  allowedGroups GroupAccess[]
  progressRecords UserProgress[]
  audioLogs     AudioLog[]
}

model Category {
  id        String      @id @default(uuid())
  name      String
  color     String?
  image     String?
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  audios    AudioTrack[]
}

model GroupAccess {
  groupId String
  audioId String

  group Group      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  audio AudioTrack @relation(fields: [audioId], references: [id], onDelete: Cascade)

  @@id([groupId, audioId])
}

model AudioAccess {
  userId  String
  audioId String

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  audio AudioTrack @relation(fields: [audioId], references: [id], onDelete: Cascade)

  @@id([userId, audioId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  tokenHash String
  userId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserProgress {
  id            String   @id @default(uuid())
  userId        String
  audioId       String
  lastPosition  Float    @default(0)
  isCompleted   Boolean  @default(false)
  isFavorite    Boolean  @default(false)
  isMyProgram   Boolean  @default(false)
  timesListened Int      @default(0)
  timesToListened Int    @default(1)
  updatedAt     DateTime @updatedAt

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  audio AudioTrack @relation(fields: [audioId], references: [id], onDelete: Cascade)

  @@unique([userId, audioId])
}

model AudioLog {
  id        String   @id @default(uuid())
  userId    String
  audioId   String
  duration  Int
  createdAt DateTime @default(now())

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  audio AudioTrack @relation(fields: [audioId], references: [id], onDelete: Cascade)
}

model AppConfig {
  key   String @id
  value String
  updatedAt DateTime @updatedAt
}
